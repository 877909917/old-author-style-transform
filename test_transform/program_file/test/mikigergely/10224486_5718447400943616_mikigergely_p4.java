package round2.p4;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.util.Arrays;
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.Set;
 
 import org.apache.commons.lang3.builder.EqualsBuilder;
 import org.apache.commons.lang3.builder.HashCodeBuilder;
 
 public class P4
 {
 	private static class Input
 	{
 		boolean[][] abilities;
 		int money;
 		
 		@Override
 		public int hashCode()
 		{
 			return new HashCodeBuilder()
 					.append( abilities )
 					.append( money )
 					.hashCode();
 		}
 		
 		@Override
 		public boolean equals( Object obj ) {
 			Input other = (Input)obj;
 			return new EqualsBuilder()
 					.append( abilities, other.abilities )
 					.append( money, other.money )
 					.isEquals();
 		}
 	}
 	
 	private static Set<Input> checked;
 	
 	private static void calculate( int N, boolean[][] abilities, BufferedWriter bw, int n ) throws Exception
 	{
 		System.out.println( n );
 		
 		checked = new HashSet<Input>();
 		
 		Input init = new Input();
 		init.abilities = abilities;
 		init.money = 0;
 		LinkedList<Input> queue = new LinkedList<Input>( Arrays.asList( init ) );
 		
 		int minMoney = check( N, queue );
 		
 		bw.append( "Case #"+n+": " + minMoney + "\n" );
 		bw.flush();
 	}
 	
 	private static int check( int N, LinkedList<Input> queue )
 	{
 		while ( true )
 		{
 			Input input = queue.pop();
 			if ( !checked.add( input ) )
 				continue;
 			
 			if ( works( N, input.abilities, new HashSet<Integer>(), new HashSet<Integer>() ) )
 				return input.money;
 			
 			for ( int i = 0; i < N; i++ )
 				for ( int j = 0; j < N; j++ )
 					if ( !input.abilities[i][j] )
 					{
 						boolean[][] abilitiesCopy = new boolean[N][N];
 						for ( int d1 = 0; d1 < N; d1++ )
 							for ( int d2 = 0; d2 < N; d2++ )
 								abilitiesCopy[d1][d2] = input.abilities[d1][d2];
 						abilitiesCopy[i][j] = true;
 						
 						Input newInput = new Input();
 						newInput.abilities = abilitiesCopy;
 						newInput.money = input.money + 1;
 						queue.add( newInput );
 					}
 		}
 	}
 	
 	private static boolean works( int N, boolean[][] abilities, Set<Integer> in, Set<Integer> machine )
 	{
 		for ( int i = 0; i < N; i++ )
 		{
 			if ( in.contains( i ) )
 				continue;
 			
 			Set<Integer> inCopy = new HashSet<>( in );
 			inCopy.add( i );
 			
 			boolean canFindWork = false;
 			for ( int j = 0; j < N; j++ )
 			{
 				if ( !abilities[i][j] || machine.contains( j ) )
 					continue;
 				canFindWork = true;
 				Set<Integer> machineCopy = new HashSet<>( machine );
 				machineCopy.add( j );
 				if ( !works( N, abilities, inCopy, machineCopy ) )
 					return false;
 			}
 			if ( !canFindWork )
 				return false;
 		}
 		
 		return true;
 	}
 	
 	public static void main( String[] args ) throws Exception
 	{
 		File inputFile = new File( "src/round2/p4/input.txt" );
 		FileReader fr = new FileReader( inputFile );
 		BufferedReader br = new BufferedReader( fr );
 		
 		int numOfTestCases = Integer.parseInt( br.readLine() );
 		
 		File outputFile = new File( "src/round2/p4/output.txt" );
 		outputFile.delete();
 		outputFile.createNewFile();
 		FileWriter fw = new FileWriter( outputFile );
 		BufferedWriter bw = new BufferedWriter( fw );
 		
 		for ( int i = 0; i < numOfTestCases; i++ )
 		{
 			String data = br.readLine();
 			
 			int N = Integer.parseInt( data );
 			boolean[][] abilities = new boolean[N][N];
 			
 			for ( int j = 0; j < N; j++ )
 			{
 				String ability = br.readLine();
 				for ( int k = 0; k < N; k++ )
 					abilities[j][k] = ability.charAt( k ) == '1';
 			}
 			
 			calculate( N, abilities, bw, i+1 );
 		}
 		
 		bw.flush();
 		fw.flush();
 		
 		br.close();
 		bw.close();
 		fw.close();
 	}
 }
